#import <XCTest/XCTest.h>
#import "CBOR.h"
//#import "CBORConstant.h"
//#import "CBORModel.h"
//#import "CBORParser.h"

#define CBORData(bytes...) \
^{\
    Byte byte[] = {bytes}; \
    NSData *data = [NSData dataWithBytes:&byte length:sizeof(byte)]; \
    return data;\
}()


@interface CBORTests : XCTestCase

@end

@implementation CBORTests

- (void)setUp {
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
}

- (void)testResult:(NSObject *)value data:(NSData *)data {
    [self testResult:value major:CBORUnknownMajorType minor:CBORUnknownMinorType data:data];
}

- (void)testResult:(NSObject *)value major:(CBORMajorType)major data:(NSData *)data {
    [self testResult:value major:major minor:CBORUnknownMinorType data:data];
}

- (void)testResult:(NSObject *)value data:(NSData *)data decodeConvert:(NSObject *(^)(NSObject *))decodeConvert {
    [self testResult:value major:CBORUnknownMajorType minor:CBORUnknownMinorType data:data decodeConvert:decodeConvert encodeConvert:nil];
}

- (void)testResult:(NSObject *)value
             major:(CBORMajorType)major
             minor:(CBORMinorType)minor
              data:(NSData *)data {
    [self testResult:value major:major minor:minor data:data decodeConvert:nil encodeConvert:nil];
}

- (void)testResult:(NSObject *)value
             major:(CBORMajorType)major
             minor:(CBORMinorType)minor
              data:(NSData *)data
     decodeConvert:(NSObject *(^)(NSObject *))decodeConvert {
    [self testResult:value major:major minor:minor data:data decodeConvert:decodeConvert encodeConvert:nil];

}
- (void)testResult:(NSObject *)value
             major:(CBORMajorType)major
             minor:(CBORMinorType)minor
              data:(NSData *)data
     decodeConvert:(NSObject *(^)(NSObject *))decodeConvert
     encodeConvert:(NSObject *(^)(NSObject *))encodeConvert {
    // 解码后的对象
    NSObject *decodedObject = [CBORParser decodeData:data];
    if (decodeConvert) {
        decodedObject = decodeConvert(decodedObject);
    }
    NSLog(@"数据：%@ => 解码对象： %@ => 期望对象： %@", data, decodedObject, value);
    
    XCTAssertTrue([decodedObject isEqualTo:value]);
    
    
    // 编码后的数据
    NSData *encodedData;
    if (encodeConvert) {
        encodedData = [CBORParser encodeObject:encodeConvert(value) major:major minor:minor];
    } else {
        encodedData = [CBORParser encodeObject:value major:major minor:minor];
    }
    NSLog(@"对象：%@ => 加密数据： %@ => 期望数据：%@", value, encodedData, data);
    XCTAssertTrue([data isEqualToData:encodedData]);
}

- (void)testDecodeOnlyResult:(NSObject *)value data:(NSData *)data {
    // 解码后的对象
    NSObject *decodedObject = [CBORParser decodeData:data];
    NSLog(@"数据：%@ => 解码对象： %@ => 期望对象： %@", data, decodedObject, value);
    XCTAssertTrue([decodedObject isEqualTo:value]);
}


/// 测试整数
- (void)testNumber {
    // 正整数
    // 首字节后5位可表示最大值
    for (CBORByte i = 0; i < CBORLengthTypeUInt8; i++) {
        [self testResult:@(i) data:CBORData(i)];
    }
    [self testResult:@(24) data:CBORData(0x18, 0x18)];
    // 1字节最大值
    // UINT8_MAX
    [self testResult:@(255) data:CBORData(0x18, 0xff)];
    // 2字节最大值
    // UINT16_MAX
    [self testResult:@(65535) data:CBORData(0x19, 0xff, 0xff)];
    // 4字节最大值
    // UINT_MAX
    [self testResult:@(4294967295) data:CBORData(0x1a, 0xff, 0xff, 0xff, 0xff)];
    // 8字节最大值
    // UINT64_MAX
    [self testResult:@(18446744073709551615U) data:CBORData(0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff)];
    
    [self testResult:@(1000) data:CBORData(0x19, 0x03, 0xe8)];
    [self testResult:@(1000000) data:CBORData(0x1a, 0x00, 0x0f, 0x42, 0x40)];
    [self testResult:@(1000000000000) data:CBORData(0x1b, 0x00, 0x00, 0x00, 0xe8, 0xd4, 0xa5, 0x10, 0x00)];
    
    // 负整数
    [self testResult:@(-1) data:CBORData(0x20)];
    [self testResult:@(-2) data:CBORData(0x21)];
    [self testResult:@(-24) data:CBORData(0x37)];
    [self testResult:@(-25) data:CBORData(0x38, 24)];
    
    // 1字节负整数最小值
    [self testResult:@(-256) data:CBORData(0x38, 0xff)];
    // 2字节负整数最小值
    [self testResult:@(-65536) data:CBORData(0x39, 0xff, 0xff)];
    // 4字节负整数最小值
    [self testResult:@(-4294967296) data:CBORData(0x3a, 0xff, 0xff, 0xff, 0xff)];
    // 理论上能达到8字节负整数最小的值
    // -9223372036854775808
    [self testResult:@(LLONG_MIN) data:CBORData(0x3b, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff)];
    
    [self testResult:@(-1000) data:CBORData(0x39, 0x03, 0xe7)];
    [self testResult:@(-1000000) data:CBORData(0x3a, 0x00, 0x0f, 0x42, 0x3f)];
    [self testResult:@(-1000000000000) data:CBORData(0x3b, 0x00, 0x00, 0x00, 0xe8, 0xd4, 0xa5, 0x0f, 0xff)];
}

/// 测试字节数组
- (void)testByteString {
    [self testResult:[NSData data] data:CBORData(0x40)];
    [self testResult:[NSData data] major:CBORMajorTypeBytes minor:CBORLengthTypeUInt8 data:CBORData(0x58, 0x00)];
    
    [self testResult:CBORData(0xf0) data:CBORData(0x41, 0xf0)];
    [self testResult:CBORData(0xf0) major:CBORMajorTypeBytes minor:CBORLengthTypeUInt8 data:CBORData(0x58, 1, 0xf0)];
    
    [self testResult:CBORData(0xc0, 0xff, 0xee) data:CBORData(0x43, 0xc0, 0xff, 0xee)];
    [self testResult:CBORData(0xc0, 0xff, 0xee) major:CBORMajorTypeBytes minor:CBORLengthTypeUInt16 data:CBORData(0x59, 0x00, 3, 0xc0, 0xff, 0xee)];
    [self testResult:CBORData(0xc0, 0xff, 0xee) major:CBORMajorTypeBytes minor:CBORLengthTypeUInt32 data:CBORData(0x5a, 0x00, 0x00, 0x00, 3, 0xc0, 0xff, 0xee)];
    
    // 不定长
    [self testDecodeOnlyResult:CBORData(0xc0, 0xff, 0xee, 0xc0, 0xff, 0xee) data:CBORData(0x5f, 0x58, 3, 0xc0, 0xff, 0xee, 0x43, 0xc0, 0xff, 0xee, 0xff)];
    
    [self testResult:CBORData(0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xaa) data:CBORData(0x57, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xaa)];
}

/// 测试字符串
- (void)testStrings {
    [self testResult:@"" data:CBORData(0x60)];
    [self testResult:@"" major:CBORMajorTypeString minor:CBORLengthTypeUInt8 data:CBORData(0x78, 0x00)];
    
    [self testResult:@"B" data:CBORData(0x61, 0x42)];
    [self testResult:@"B" major:CBORMajorTypeString minor:CBORLengthTypeUInt8 data:CBORData(0x78, 0x01, 0x42)];
    
    [self testResult:@"ABC" data:CBORData(0x63, 0x41, 0x42, 0x43)];
    [self testResult:@"ABC" major:CBORMajorTypeString minor:CBORLengthTypeUInt16 data:CBORData(0x79, 0x00, 3, 0x41, 0x42, 0x43)];
    
    [self testResult:@"道可道" data:CBORData(0x69, 0xE9, 0x81, 0x93, 0xE5, 0x8F, 0xAF, 0xE9, 0x81, 0x93)];
    // 不定长
    [self testDecodeOnlyResult:@"道可道道可道" data:CBORData(0x7f, 0x69, 0xE9, 0x81, 0x93, 0xE5, 0x8F, 0xAF, 0xE9, 0x81, 0x93, 0x69, 0xE9, 0x81, 0x93, 0xE5, 0x8F, 0xAF, 0xE9, 0x81, 0x93, 0xff)];
    [self testResult:@"\u{6C34}" data:CBORData(0x63, 0xe6, 0xb0, 0xb4)];
    [self testResult:@"abc\n123" data:CBORData(0x67, 0x61, 0x62, 0x63, 0x0a, 0x31, 0x32, 0x33)];
}

/// 测试数组
- (void)testArrays {
    [self testResult:@[] data:CBORData(0x80)];
    [self testResult:@[] major:CBORMajorTypeArray minor:CBORLengthTypeUInt8 data:CBORData(0x98, 0)];
    
    [self testResult:@[@(1), @"ABC"] data:CBORData(0x82, 0x01, 0x63, 0x41, 0x42, 0x43)];
    // 子长度用字节无法适配 毁灭吧～
    [self testDecodeOnlyResult:@[@(1), @"ABC"] data:CBORData(0x82, 0x18, 1, 0x79, 0x00, 3, 0x41, 0x42, 0x43)];
    
    [self testDecodeOnlyResult:@[@[@1], @[@2, @3], @[@4, @5]] data:CBORData(0x9f, 0x81, 0x01, 0x82, 0x02, 0x03, 0x9f, 0x04, 0x05, 0xff, 0xff)];
    [self testResult:@[@[@1], @[@2, @3], @[@4, @5]] data:CBORData(0x83, 0x81, 0x01, 0x82, 0x02, 0x03, 0x82, 0x04, 0x05)];
}

/// 测试字典
- (void)testMaps {
    [self testResult:@{} data:CBORData(0xa0)];
    NSData *loremIpsumData = CBORData(0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x51, 0x75, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x65, 0x78, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x2c, 0x20, 0x73, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x75, 0x74, 0x20, 0x66, 0x61, 0x75, 0x63, 0x69, 0x62, 0x75, 0x73, 0x20, 0x70, 0x68, 0x61, 0x72, 0x65, 0x74, 0x72, 0x61, 0x2c, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6d, 0x73, 0x61, 0x6e, 0x20, 0x65, 0x74, 0x20, 0x61, 0x75, 0x67, 0x75, 0x65, 0x2e, 0x20, 0x56, 0x65, 0x73, 0x74, 0x69, 0x62, 0x75, 0x6c, 0x75, 0x6d, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x2c, 0x20, 0x65, 0x75, 0x20, 0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x63, 0x69, 0x20, 0x6c, 0x61, 0x63, 0x69, 0x6e, 0x69, 0x61, 0x20, 0x71, 0x75, 0x69, 0x73, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x69, 0x6e, 0x20, 0x73, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x64, 0x75, 0x69, 0x20, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x72, 0x61, 0x74, 0x2c, 0x20, 0x69, 0x64, 0x20, 0x62, 0x6c, 0x61, 0x6e, 0x64, 0x69, 0x74, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x76, 0x65, 0x68, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x2e, 0x20, 0x4d, 0x61, 0x65, 0x63, 0x65, 0x6e, 0x61, 0x73, 0x20, 0x61, 0x63, 0x20, 0x6e, 0x69, 0x73, 0x6c, 0x20, 0x61, 0x20, 0x6f, 0x64, 0x69, 0x6f, 0x20, 0x76, 0x61, 0x72, 0x69, 0x75, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x20, 0x6c);
    [self testDecodeOnlyResult:@{
        @"off": @(0),
        @"data": loremIpsumData,
        @"rc": @(0),
        @"len": @(300)
    } data:CBORData(0xbf, 0x63, 0x6f, 0x66, 0x66, 0x00, 0x64, 0x64, 0x61, 0x74, 0x61, 0x59, 0x01, 0x2c, 0x4c, 0x6f, 0x72, 0x65, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x51, 0x75, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x65, 0x78, 0x20, 0x61, 0x6e, 0x74, 0x65, 0x2c, 0x20, 0x73, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x20, 0x75, 0x74, 0x20, 0x66, 0x61, 0x75, 0x63, 0x69, 0x62, 0x75, 0x73, 0x20, 0x70, 0x68, 0x61, 0x72, 0x65, 0x74, 0x72, 0x61, 0x2c, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6d, 0x73, 0x61, 0x6e, 0x20, 0x65, 0x74, 0x20, 0x61, 0x75, 0x67, 0x75, 0x65, 0x2e, 0x20, 0x56, 0x65, 0x73, 0x74, 0x69, 0x62, 0x75, 0x6c, 0x75, 0x6d, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x20, 0x6c, 0x69, 0x67, 0x75, 0x6c, 0x61, 0x2c, 0x20, 0x65, 0x75, 0x20, 0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x72, 0x63, 0x69, 0x20, 0x6c, 0x61, 0x63, 0x69, 0x6e, 0x69, 0x61, 0x20, 0x71, 0x75, 0x69, 0x73, 0x2e, 0x20, 0x50, 0x72, 0x6f, 0x69, 0x6e, 0x20, 0x73, 0x63, 0x65, 0x6c, 0x65, 0x72, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x64, 0x75, 0x69, 0x20, 0x61, 0x74, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x72, 0x61, 0x74, 0x2c, 0x20, 0x69, 0x64, 0x20, 0x62, 0x6c, 0x61, 0x6e, 0x64, 0x69, 0x74, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x76, 0x65, 0x68, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x2e, 0x20, 0x4d, 0x61, 0x65, 0x63, 0x65, 0x6e, 0x61, 0x73, 0x20, 0x61, 0x63, 0x20, 0x6e, 0x69, 0x73, 0x6c, 0x20, 0x61, 0x20, 0x6f, 0x64, 0x69, 0x6f, 0x20, 0x76, 0x61, 0x72, 0x69, 0x75, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x20, 0x6c, 0x62, 0x72, 0x63, 0x00, 0x63, 0x6c, 0x65, 0x6e, 0x19, 0x01, 0x2c, 0xff)];
    [self testResult:@{@"key": @(-24)} data:CBORData(0xa1, 0x63, 0x6b, 0x65, 0x79, 0x37)];
    [self testResult:@{@"key": @[@(-24)]} data:CBORData(0xa1, 0x63, 0x6b, 0x65, 0x79, 0x81, 0x37)];
    [self testDecodeOnlyResult:@{@"key": @{@"key": @(-24)}} data:CBORData(0xbf, 0x63, 0x6b, 0x65, 0x79, 0xa1, 0x63, 0x6b, 0x65, 0x79, 0x37, 0xff)];
    [self testDecodeOnlyResult:@{@"key": @{@"key": @(-24)}} data:CBORData(0xbf, 0x63, 0x6b, 0x65, 0x79, 0xa1, 0x63, 0x6b, 0x65, 0x79, 0x37, 0xff)];
    [self testResult:@{@"_id": @"aaa", @"category": @"cake", @"ordinal": @(12.0f)} data:CBORData(0xa3, 0x63, 0x5f, 0x69, 0x64, 0x63, 0x61, 0x61, 0x61, 0x68, 0x63, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79, 0x64, 0x63, 0x61, 0x6b, 0x65, 0x67, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x6c, 0xf9, 0x4A, 0x00)];
    [self testResult:@{@(1): @(2)} data:CBORData(0xa1, 0x01, 0x02)];
}

/// 测试简单类型
- (void)testSimple {
    [self testResult:[NSNull null] data:CBORData(0xf6)];
    [self testResult:@(YES) data:CBORData(0xf5)];
    [self testResult:@(NO) data:CBORData(0xf4)];
    [self testResult:[CBORUndefined new] data:CBORData(0xf7)];
    // 0xff
    [self testResult:[CBORBreak new] data:CBORData(CBORMajorTypeAdditional | CBORAdditionalTypeBreak)];
    
    [self testResult:@(0) major:CBORMajorTypeAdditional data:CBORData(0xe0)];
    [self testResult:@(16) major:CBORMajorTypeAdditional data:CBORData(0xf0)];
    [self testResult:@(19) major:CBORMajorTypeAdditional data:CBORData(0xf3)];
    [self testResult:@(32) major:CBORMajorTypeAdditional data:CBORData(0xf8, 0x20)];
    [self testResult:@(255) major:CBORMajorTypeAdditional data:CBORData(0xf8, 0xff)];
}

/// 测试浮点数
- (void)testFloat {
    [self testResult:@(0.0) data:CBORData(0xf9, 0, 0)];
    [self testResult:@(0.0f) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeFloat data:CBORData(0xfa, 0, 0, 0, 0)];
    [self testResult:@(0.0f) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeDouble data:CBORData(0xfb,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
   
    [self testResult:@(-0.0f) data:CBORData(0xf9, 0x80, 0)];
    [self testResult:@(1.0f) data:CBORData(0xf9, 0x3c, 0)];
    [self testResult:@(1.5f) data:CBORData(0xf9, 0x3e, 0x00)];
    [self testResult:@(1.0f) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeDouble data:CBORData(0xfb, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
    // 半精度最大值
    // 65504.0
    [self testResult:@(CBOR_HALF_MAX) data:CBORData(0xf9, 0x7b, 0xff)];
    // 半精度最小值
    // -65504.0
    [self testResult:@(CBOR_HALF_MIN) data:CBORData(0xf9, 0xfb, 0xff)];
    
    // 单精度最大值
    // 3.402823466385289e+38
    [self testResult:@(FLT_MAX) data:CBORData(0xfa, 0x7f, 0x7f, 0xff, 0xff)];
    // 1.1754943508222875e-38
    [self testResult:@(FLT_MIN) data:CBORData(0xfa, 0x00, 0x80, 0x00, 0x00)];
    
    // 双精度最大值
    // 1.7976931348623158e+308
    [self testResult:@(DBL_MAX) data:CBORData(0xFB, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF)];
    // 双精度最小值
    // 2.2250738585072014e-308
    [self testResult:@(DBL_MIN) data:CBORData(0xFB, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
    
    [self testResult:@(-65505.0f) data:CBORData(0xfa, 0xc7, 0x7f, 0xe1, 0x00)];
    [self testResult:@(65505.0f) data:CBORData(0xfa, 0x47, 0x7f, 0xe1, 0x00)];
    [self testResult:@(100000.0f) data:CBORData(0xfa, 0x47, 0xc3, 0x50, 0x00)];
    
    [self testResult:@(INFINITY) data:CBORData(0xf9, 0x7c, 0x00)];
    [self testResult:@(INFINITY) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeFloat data:CBORData(0xfa, 0x7f, 0x80, 0x00, 0x00)];
    [self testResult:@(INFINITY) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeDouble data:CBORData(0xfb, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
    
    [self testResult:@(-INFINITY) data:CBORData(0xf9, 0xfc, 0x00)];
    [self testResult:@(-INFINITY) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeFloat data:CBORData(0xfa, 0xff, 0x80, 0x00, 0x00)];
    [self testResult:@(-INFINITY) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeDouble data:CBORData(0xfb, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
    
    [self testResult:@(NAN) data:CBORData(0xf9, 0x7e, 0x00)];
    [self testResult:@(NAN) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeFloat data:CBORData(0xfa, 0x7f, 0xc0, 0x00, 0x00)];
    [self testResult:@(NAN) major:CBORMajorTypeAdditional minor:CBORAdditionalTypeDouble data:CBORData(0xfb, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)];
    
    [self testResult:@((double)1.1) data:CBORData(0xfb, 0x3f, 0xf1, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a)];
    [self testResult:@((double)-4.1) data:CBORData(0xfb, 0xc0, 0x10, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66)];
    
    [self testResult:@(1.0e+300) data:CBORData(0xfb, 0x7e, 0x37, 0xe4, 0x3c, 0x88, 0x00, 0x75, 0x9c)];
    [self testResult:@(5.960464477539063e-8) data:CBORData(0xf9, 0x00, 0x01)];
    
    // 3.141592653589793
    [self testResult:@(M_PI) data:CBORData(0xfb, 0x40, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18)];
    
    [self testResult:@(5.5f) data:CBORData(0xf9, 0x45, 0x80)];
    [self testResult:@(5.6) data:CBORData(0xFB, 0x40, 0x16, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66)];
}

/// 测试日期
- (void)testDate {
    // Date
    [self testResult:[NSDate dateWithTimeIntervalSince1970:1363896240] data:CBORData(0xc1, 0x1a, 0x51, 0x4b, 0x67, 0xb0) decodeConvert:^NSObject *(NSObject *value) {
        if (![value isKindOfClass:[NSNumber class]]) { return nil; }
        return [NSDate dateWithTimeIntervalSince1970:[(NSNumber *)value doubleValue]];
    }];
    
    [self testResult:[NSDate dateWithTimeIntervalSince1970:1363896240]
               major:CBORMajorTypeTag
               minor:CBORTagTypeStandardDateTimeString
                data:CBORData(
                              0xc0, 0x78, 0x18, // Tag 0, String Length 24
                              0x32, 0x30, 0x31, 0x33, // 2013
                              0x2D,         // -
                              0x30, 0x33,   // 03
                              0x2D,         // -
                              0x32, 0x32,   // 22
                              0x54,         // T
                              0x30, 0x34,   // 04 <= 20 时区转化
                              0x3A,         // :
                              0x30, 0x34,   // 04
                              0x3A,         // :
                              0x30, 0x30,   // 00
                              0x2B, 0x30, 0x38, 0x30, 0x30 // +0800
                              ) decodeConvert:^NSObject *(NSObject *value) {
        if (![value isKindOfClass:[NSString class]]) { return nil; }
        NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
        formatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ssZ";
        formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
        formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0];
        return [formatter dateFromString:(NSString *)value];
    }];
    [self testResult:@(729187200) major:CBORMajorTypeTag minor:CBORTagTypeEpochBasedDateTime data:CBORData(0xc1, 0x1a, 0x2B, 0x76, 0x83, 0x80)];
    [self testResult:@"1993-02-09T00:00:00Z" major:CBORMajorTypeTag minor:CBORTagTypeStandardDateTimeString data:CBORData(0xc0, 0x74, 0x31, 0x39, 0x39, 0x33, 0x2D, 0x30, 0x32, 0x2D, 0x30, 0x39, 0x54, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x3A, 0x30, 0x30, 0x5A)];
}

static inline UInt64 ConvertDataToBignumN(NSData *data) {
    const uint8_t *bytes = [data bytes];
    NSUInteger length = [data length];
    uint8_t byteLength = 8;
    UInt64 ret = 0;
    
    for (NSUInteger index = 0; index < length; index++) {
        uint8_t byte = bytes[index];
        for (uint8_t offset = 0; offset < byteLength; offset++) {
            if ((byte & (1 << offset)) == 0) { continue; }
            // 二进制1从右到左所在序号和
            ret += (length - 1 - index) * byteLength + offset;
        }
    }
    
    return ret;
}

- (void)testTags {
    [self testResult:@(256)
               major:CBORMajorTypeTag
               minor:CBORTagTypePositiveBignum
                data:CBORData(0xc2, 0x42, 0x01, 0x00)
       decodeConvert:^NSObject *(NSObject *value) {
        if (![value isKindOfClass:[NSData class]]) { return nil; }
        
        UInt64 ret = ConvertDataToBignumN((NSData *)value);
        
        return @((UInt64)exp2f(ret));
    }
       encodeConvert:^NSObject *(NSObject *value) {
        // CBORTagTypePositiveBignum类型应该是Byte数组，对应原生即NSData
        return CBORData(0x01, 0x00);
    }];
    
    [self testResult:@(-257)
               major:CBORMajorTypeTag
               minor:CBORTagTypeNegativeBignum
                data:CBORData(0xc3, 0x42, 0x01, 0x00)
       decodeConvert:^NSObject *(NSObject *value) {
        if (![value isKindOfClass:[NSData class]]) { return nil; }
        
        UInt64 ret = ConvertDataToBignumN((NSData *)value);
        return @((SInt64)~((UInt64)exp2f(ret)));
    }
       encodeConvert:^NSObject *(NSObject *value) {
        // CBORTagTypePositiveBignum类型应该是Byte数组，对应原生即NSData
        return CBORData(0x01, 0x00);
    }];
    
    [self testResult:@(273.15f)
               major:CBORMajorTypeTag
               minor:CBORTagTypeDecimalFraction
                data:CBORData(0xc4, 0x82, 0x21, 0x19, 0x6a, 0xb3)
       decodeConvert:^NSObject *(NSObject *value) {
        // CBORTagTypeDecimalFraction类型应该是数组类型，且数组长度为2
        if (![value isKindOfClass:[NSArray class]]
            || [(NSArray *)value count] != 2) { return nil; }
        
        /// 指数
        NSNumber *exponent = ((NSArray *)value)[0];
        if (![exponent isKindOfClass:[NSNumber class]]) { return nil; }
        /// 尾数
        NSNumber *mantissa = ((NSArray *)value)[1];
        if (![mantissa isKindOfClass:[NSNumber class]]) { return nil; }
        
        float exponentValue = [exponent floatValue];
        SInt64 mantissaValue = [mantissa longLongValue];
        // 尾数 * 10^指数
        return @((float)(mantissaValue * pow(10, exponentValue)));
    } encodeConvert:^NSObject *(NSObject *value) {
        return @[@(-2), @(27315)];
    }];
    
    [self testResult:@(1.5f)
               major:CBORMajorTypeTag
               minor:CBORTagTypeBigfloat
                data:CBORData(0xc5, 0x82, 0x20, 0x03)
       decodeConvert:^NSObject *(NSObject *value) {
        // CBORTagTypeDecimalFraction类型应该是数组类型，且数组长度为2
        if (![value isKindOfClass:[NSArray class]]
            || [(NSArray *)value count] != 2) { return nil; }
        
        /// 指数
        NSNumber *exponent = ((NSArray *)value)[0];
        if (![exponent isKindOfClass:[NSNumber class]]) { return nil; }
        /// 尾数
        NSNumber *mantissa = ((NSArray *)value)[1];
        if (![mantissa isKindOfClass:[NSNumber class]]) { return nil; }
        
        float exponentValue = [exponent floatValue];
        SInt64 mantissaValue = [mantissa longLongValue];
        // 尾数 * 2^指数
        return @((float)(mantissaValue * pow(2, exponentValue)));
    } encodeConvert:^NSObject *(NSObject *value) {
        return @[@(-1), @(3)];
    }];
    
    [self testResult:@"Hello, World!"
               major:CBORMajorTypeTag
               minor:CBORTagTypeBase64
                data:CBORData(0xd8, 0x22, 0x74, 0x53, 0x47, 0x56, 0x73, 0x62, 0x47, 0x38, 0x73, 0x49, 0x46, 0x64, 0x76, 0x63, 0x6D, 0x78, 0x6B, 0x49, 0x51, 0x3D, 0x3D)];
    
    [self testResult:@"Hello, World!"
               major:CBORMajorTypeTag
               minor:CBORTagTypeBase64URL
                data:CBORData(0xd8, 0x21, 0x74, 0x53, 0x47, 0x56, 0x73, 0x62, 0x47, 0x38, 0x73, 0x49, 0x46, 0x64, 0x76, 0x63, 0x6D, 0x78, 0x6B, 0x49, 0x51, 0x3D, 0x3D)];
}

@end
